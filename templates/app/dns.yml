AWSTemplateFormatVersion: "2010-09-09"

Description: "A stack containing the resources to route traffic to the appropriate destination, via AWS DNS record sets. This stack should be stood up after the rest of the application stack, once everything else has been successfully provisioned. The template can conditionally provision the hosted zone and certificate for a domain that has been registered. If template is not told to configure this values, it will need the hosted zone ID and the certificate ID passed in through parameters"

Parameters:
  DNS:
    Type: String
    Description: "If DNS has been configured, you do not need this parameter. If you want to set up the DNS configuration for a domain, pass in `true`."
    AllowedValues:
      - true
      - false
    Default: false
  domain:
    Type: String
    Default: makpar-innovation.com
  subdomain:
    Type: String
    Default: laboratory
  environmentName:
    Type: String
    Default: Dev
  applicationName:
    Type: String
    Default: innolab
  certificateId:
    Type: String
    Description: "If the DNS has been configured prior to this template, you must pass in the CertificateId for the associated domain. Otherwise, you do not need this parameter."
    Default: ${AWS::NoValue}
  hostedZoneId:
    Type: String
    Description: "If the DNS has been configured prior to this template, you must pass in the HostedZoneId for the associated domain and record set. Otherwise, you do not need this paramter."
    Default: ${AWS::NoValue}    
  sonarStack:
    Type: String
    Default: Innolab-SonarStack
  lambdaStack:
    Type: String
    Default: Innolab-LambdaStack-Dev
  ecsStack:
    Type: String
    Default: Innolab-ECSStack-Dev

Conditions:
  DNSExists: !Equals 
    - !Ref DNS
    - true
  
  NotDNSExists: !Not
    - Condition: DNSExists

  DevResources: !Equals
  - !Ref environmentName
  - Dev

Mappings:
  SubEnvDomainMap:
    Dev: 
      subdomainEnv:  "-dev"
    Test: 
      subdomainEnv: "-test"
    Staging: 
      subdomainEnv: "-staging"
    Prod: 
      subdomainEnv: ""

Resources:
  HostedZone:
    Description: "Hosted Zone that is provisioned if DNS configuration does not exist."
    Condition: NotDNSExists
    Type: 'AWS::Route53::HostedZone'
    Properties:
      Name: !Sub "${domain}"

  Certificate:
    Description: "Certificate that is provisioned if DNS confiuration does not exist."
    Condition: NotDNSExists
    Type: 'AWS::CertificateManager::Certificate'
    Properties:
      DomainName: !Sub "*.${domain}"
      ValidationMethod: DNS

  RestAPIDomainName:
    Type: 'AWS::ApiGateway::DomainName'
    Properties:
      CertificateArn: 
        !If [DNSExists, !Sub "arn:aws:acm:us-east-1:${AWS::AccountId}:certificate/${certificateId}", !Sub "arn:aws:acm:us-east-1:${AWS::AccountId}:certificate/${Certificate}"]
      DomainName: !Sub 
        - "api-${subdomainName}${subdomainEnv}.${domainName}"
        - subdomainEnv: 
            Fn::FindInMap:
              - SubEnvDomainMap
              - !Ref environmentName
              - subdomainEnv
          subdomainName: !Ref subdomain
          domainName: !Ref domain
      EndpointConfiguration:
        Types:
          - EDGE

  RestAPIBasePathMapping:
    Type: 'AWS::ApiGateway::BasePathMapping'
    Properties:
      DomainName: !Ref RestAPIDomainName
      RestApiId: 
        Fn::ImportValue: !Sub ${lambdaStack}-RestAPIID
      Stage: !Ref environmentName

  RestAPIRoute53RecordSetGroup:
    Type: AWS::Route53::RecordSetGroup
    Properties:
      HostedZoneId: !If [DNSExists, !Ref hostedZoneId, !Ref HostedZone]
      RecordSets:
        - Name: !Sub 
            - "api-${subdomainName}${subdomainEnv}.${domainName}"
            - subdomainEnv: 
                Fn::FindInMap:
                  - SubEnvDomainMap
                  - !Ref environmentName
                  - subdomainEnv
              subdomainName: !Ref subdomain
              domainName: !Ref domain
          Type: A
          AliasTarget:
            HostedZoneId: !GetAtt RestAPIDomainName.DistributionHostedZoneId
            DNSName: !GetAtt RestAPIDomainName.DistributionDomainName
    DependsOn:
      - RestAPIDomainName

  BucketLogs:
    Type: AWS::S3::Bucket
    Condition: DevResources
    DeletionPolicy: Delete
    Properties:
      AccessControl: LogDeliveryWrite
      BucketName: !Sub "${applicationName}-coverage-logs"

  CoverageBucket:
    Type: AWS::S3::Bucket
    Condition: DevResources
    DeletionPolicy: Delete
    Properties:
      AccessControl: PublicRead
      BucketName: !Sub "${applicationName}-coverage"
      LoggingConfiguration:
        DestinationBucketName: !Ref BucketLogs
        LogFilePrefix: 'cov/'
      WebsiteConfiguration:
        IndexDocument: 'index.html'

  CoverageBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Condition: DevResources
    Properties:
      Bucket: !Ref CoverageBucket
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: 'Allow'
            Action: 
              - "s3:GetObject"
              - "s3:PutObject"
              - "s3:DeleteObject"
            Principal: '*'
            Resource: !Sub '${CoverageBucket.Arn}/*'
    DependsOn:
      - CoverageBucket

  CoverageDistribution:
    Type: "AWS::CloudFront::Distribution"
    Condition: DevResources
    Properties:
      DistributionConfig: 
        Aliases: 
          - !Sub "${subdomain}-coverage.${domain}"
        Origins: 
        - ConnectionAttempts: 3
          ConnectionTimeout: 10
          DomainName: !GetAtt CoverageBucket.DomainName
          Id: !Ref CoverageBucket
          CustomOriginConfig:
              HTTPPort: 80
              HTTPSPort: 443
              OriginKeepaliveTimeout: 5
              OriginProtocolPolicy: 'https-only'
              OriginReadTimeout: 30
              OriginSSLProtocols:
                - TLSv1
                - TLSv1.1
                - TLSv1.2
        DefaultCacheBehavior: 
          AllowedMethods: 
          - "HEAD"
          - "DELETE"
          - "POST"
          - "GET"
          - "OPTIONS"
          - "PUT"
          - "PATCH"
          CachedMethods: 
          - "HEAD"
          - "GET"
          ForwardedValues:
            Cookies:
              Forward: none
            QueryString: true
          Compress: false
          SmoothStreaming: false
          TargetOriginId: !Ref CoverageBucket
          ViewerProtocolPolicy: "redirect-to-https"
        PriceClass: "PriceClass_All"
        Enabled: true
        ViewerCertificate: 
          AcmCertificateArn: !If [DNSExists, !Sub "arn:aws:acm:us-east-1:${AWS::AccountId}:certificate/${certificateId}", !Sub "arn:aws:acm:us-east-1:${AWS::AccountId}:certificate/${Certificate}"]
          MinimumProtocolVersion: "TLSv1.2_2019"
          SslSupportMethod: "sni-only"
        HttpVersion: "http2"
        DefaultRootObject: 'index.html'
        IPV6Enabled: true
        Logging:
          Bucket: !GetAtt BucketLogs.DomainName
          IncludeCookies: false
          Prefix: 'cov/'

  CoverageRoute53RecordSetGroup:
    Type: AWS::Route53::RecordSetGroup
    Condition: DevResources
    Properties:
      HostedZoneId: !If [DNSExists, !Ref hostedZoneId, !Ref HostedZone]
      RecordSets:
        - Name: !Sub "${subdomain}-coverage.${domain}"
          Type: A
          AliasTarget:
            DNSName: !GetAtt CoverageDistribution.DomainName
            EvaluateTargetHealth: false
            # Specify Z2FDTNDATAQYW2. This is always the hosted zone ID when you create an
            # alias record that routes traffic to a CloudFront distribution.
            HostedZoneId: Z2FDTNDATAQYW2
    DependsOn:
      - CoverageDistribution

  ECSRecord:
    Type: AWS::Route53::RecordSet
    Properties:
      HostedZoneId: !If [DNSExists, !Ref hostedZoneId, !Ref HostedZone]
      Name: !Sub
        - "${subdomainName}${subdomainEnv}.${domainName}"
        - subdomainName: !Ref subdomain
          domainName: !Ref domain
          subdomainEnv: 
            Fn::FindInMap:
              - SubEnvDomainMap
              - !Ref environmentName
              - subdomainEnv
      Type: A
      AliasTarget:
        DNSName: 
          Fn::ImportValue: !Sub "${ecsStack}-FrontendLoadBalancerDNSName" 
        HostedZoneId:
          Fn::ImportValue: !Sub "${ecsStack}-FrontendLoadBalancerHostedZoneID"

Outputs: 
  RestAPIDomain:
    Condition: DNSExists
    Value: !Ref RestAPIDomainName
    Export:
      Name: !Sub ${AWS::StackName}-RestAPIDomainName
  CertificateId:
    Condition: NotDNSExists
    Value: !If [NotDNSExists, !Ref Certificate, !Ref certificateId]
    Export:
      Name: !Sub ${AWS::StackName}-CertificateID
  HostedZoneId:
    Condition: NotDNSExists
    Value: !If [NotDNSExists, !Ref HostedZone, !Ref hostedZoneId]
    Export:
      Name: !Sub ${AWS::StackName}-HostedZoneID
  CoverageDistributionID:
    Condition: DevResources
    Value: !Ref CoverageDistribution
    Description: Resource ID for CloudFront Distribution
    Export:
      Name: !Sub ${AWS::StackName}-CoverageDistributionID
  CoverageDomain:
    Condition: DevResources
    Value: !GetAtt CoverageDistribution.DomainName
    Description: Domain name of CloudFront Distribution
    Export:
      Name: !Sub ${AWS::StackName}-CoverageDistributionDomain