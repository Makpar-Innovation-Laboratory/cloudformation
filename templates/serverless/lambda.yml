AWSTemplateFormatVersion: "2010-09-09"

Description: 'Provisions a series of Lambda functions, gives them an execution role for the VPC from ${applicationName}-VPCStack-${environmentName} and attaches policies to update the function code to the pipeline role from the ${applicationName}-IAMStack. The execution images for the Lambdas are pulled from the repositores in ${applicationName}-RepoStack.'

Parameters:
  ## CROSS STACK REFERENCES
  iamStack:
    Type: String
    Default: Innolab-IAMStack
  vpcStack:
    Type: String
    Default: Innolab-VPCStack-Dev
  cognitoStack:
    Type: String
    Default: Innolab-CognitoStack-Dev
  repoStack:
    Type: String
    Default: Innolab-RepoStack
  ## APPLICATION CONFIGURATION
  environmentName:
    Type: String
    Default: Dev
  applicationName:
    Type: String
    Default: innolab
  domainName: 
    Type: String
    Default: makpar-innovation.net
  hostedZoneId:
    Type: String
    Description: Physical ID of the hosted zone where the domain is being served.
  certificateArn:
    Type: String
    Description: ARN of the ACM SSL Certificate used to sign requests to domain.

Conditions:
  DevResources: !Equals
    - !Ref environmentName
    - Dev

Mappings:
  BranchMap:
    Dev: 
      branch:  "dev"
      subdomain: "-dev"
    Test: 
      branch: "test"
      subdomain: "-test"
    Staging: 
      branch: "staging"
      subdomain: "-staging"
    Prod: 
      branch: "prod"
      subdomain: ""

Resources:
  # API Gateway Path Lambda
  LambdaAlpha: 
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub ${applicationName}-lambda-alpha-${environmentName}
      Code: 
        ImageUri: !Sub
          - "${ecrRepo}:${environment}"
          - ecrRepo: 
              Fn::ImportValue: !Sub ${repoStack}-LambdaAlphaImageRepository
            environment: !Ref environmentName
      PackageType: Image
      Role: 
        Fn::ImportValue: !Sub ${iamStack}-LambdaExecutorRoleArn
      VpcConfig:
        SecurityGroupIds: 
          - Fn::ImportValue: !Sub ${vpcStack}-DatabaseSecurityGroup
        SubnetIds:
          - Fn::ImportValue: !Sub ${vpcStack}-PrivateSubnetA
          - Fn::ImportValue: !Sub ${vpcStack}-PrivateSubnetB
      Environment:
        Variables:
          CLIENT_ID: 
            Fn::ImportValue: !Sub ${cognitoStack}-APIClientID
          POOL_ID:
            Fn::ImportValue: !Sub ${cognitoStack}-UserPoolID
          # POSTGRES_DB: !Ref applicationName
          # POSTGRES_HOST: !Sub '{{resolve:secretsmanager:${applicationName}-${environmentName}-dbHost:SecretString}}'
          # POSTGRES_USER: !Sub '{{resolve:secretsmanager:${applicationName}-${environmentName}-dbUsername:SecretString}}'
          # POSTGRES_PASSWORD: !Sub '{{resolve:secretsmanager:${applicationName}-${environmentName}-dbPassword:SecretString}}'
      Timeout: 90

  LambdaBeta: 
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub ${applicationName}-lambda-beta-${environmentName}
      Code: 
        ImageUri: !Sub
          - "${ecrRepo}:${environment}"
          - ecrRepo: 
              Fn::ImportValue: !Sub ${repoStack}-LambdaBetaImageRepository
            environment: !Ref environmentName
      PackageType: Image
      Role: 
        Fn::ImportValue: !Sub ${iamStack}-LambdaExecutorRoleArn
      VpcConfig:
        SecurityGroupIds: 
          - Fn::ImportValue: !Sub ${vpcStack}-DatabaseSecurityGroup
        SubnetIds: 
          - Fn::ImportValue: !Sub ${vpcStack}-PrivateSubnetA
          - Fn::ImportValue: !Sub ${vpcStack}-PrivateSubnetB
      Environment:
        Variables:
          CLIENT_ID: 
            Fn::ImportValue: !Sub ${cognitoStack}-APIClientID
          POOL_ID:
            Fn::ImportValue: !Sub ${cognitoStack}-UserPoolID
          # POSTGRES_DB: !Ref applicationName
          # POSTGRES_HOST: !Sub '{{resolve:secretsmanager:${applicationName}-${environmentName}-dbHost:SecretString}}'
          # POSTGRES_USER: !Sub '{{resolve:secretsmanager:${applicationName}-${environmentName}-dbUsername:SecretString}}'
          # POSTGRES_PASSWORD: !Sub '{{resolve:secretsmanager:${applicationName}-${environmentName}-dbPassword:SecretString}}'
      Timeout: 90

  LambdaGamma:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub ${applicationName}-lambda-gamma-${environmentName}
      Code: 
        ImageUri: !Sub
          - "${ecrRepo}:${environment}"
          - ecrRepo: 
              Fn::ImportValue: !Sub ${repoStack}-LambdaGammaImageRepository
            environment: !Ref environmentName
      PackageType: Image
      Role: 
        Fn::ImportValue: !Sub ${iamStack}-LambdaExecutorRoleArn
      VpcConfig:
        SecurityGroupIds: 
          - Fn::ImportValue: !Sub ${vpcStack}-DatabaseSecurityGroup
        SubnetIds: 
          - Fn::ImportValue: !Sub ${vpcStack}-PrivateSubnetA
          - Fn::ImportValue: !Sub ${vpcStack}-PrivateSubnetB
      MemorySize: 4000 
      Environment:
        Variables:
          CLIENT_ID: 
            Fn::ImportValue: !Sub ${cognitoStack}-APIClientID
          POOL_ID:
            Fn::ImportValue: !Sub ${cognitoStack}-UserPoolID
          # POSTGRES_DB: !Ref applicationName
          # POSTGRES_HOST: !Sub '{{resolve:secretsmanager:${applicationName}-${environmentName}-dbHost:SecretString}}'
          # POSTGRES_USER: !Sub '{{resolve:secretsmanager:${applicationName}-${environmentName}-dbUsername:SecretString}}'
          # POSTGRES_PASSWORD: !Sub '{{resolve:secretsmanager:${applicationName}-${environmentName}-dbPassword:SecretString}}'
      Timeout: 90

  LambdaDelta:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub ${applicationName}-lambda-delta-${environmentName}
      Code: 
        ImageUri: !Sub
          - "${ecrRepo}:${environment}"
          - ecrRepo: 
              Fn::ImportValue: !Sub ${repoStack}-LambdaDeltaImageRepository
            environment: !Ref environmentName
      PackageType: Image
      Role: 
        Fn::ImportValue: !Sub ${iamStack}-LambdaExecutorRoleArn
      VpcConfig:
        SecurityGroupIds: 
          - Fn::ImportValue: !Sub ${vpcStack}-DatabaseSecurityGroup
        SubnetIds: 
            - Fn::ImportValue: !Sub ${vpcStack}-PrivateSubnetA
            - Fn::ImportValue: !Sub ${vpcStack}-PrivateSubnetB
      Environment:
        Variables:
          CLIENT_ID: 
            Fn::ImportValue: !Sub ${cognitoStack}-APIClientID
          POOL_ID:
            Fn::ImportValue: !Sub ${cognitoStack}-UserPoolID
          # POSTGRES_DB: !Ref applicationName
          # POSTGRES_HOST: !Sub '{{resolve:secretsmanager:${applicationName}-${environmentName}-dbHost:SecretString}}'
          # POSTGRES_USER: !Sub '{{resolve:secretsmanager:${applicationName}-${environmentName}-dbUsername:SecretString}}'
          # POSTGRES_PASSWORD: !Sub '{{resolve:secretsmanager:${applicationName}-${environmentName}-dbPassword:SecretString}}'
      Timeout: 90

  LambdaEpsilon:
    Type: AWS::Lambda::Function
    Properties: 
      FunctionName: !Sub ${applicationName}-lambda-epsilon-${environmentName}
      Code:
        ImageUri: !Sub
          - "${ecrRepo}:${environment}"
          - ecrRepo:
              Fn::ImportValue: !Sub ${repoStack}-LambdaEpsilonImageRepository
            environment: !Ref environmentName
      PackageType: Image
      Role:
        Fn::ImportValue: !Sub ${iamStack}-LambdaExecutorRoleArn
      VpcConfig:
        SecurityGroupIds: 
          - Fn::ImportValue: !Sub ${vpcStack}-DatabaseSecurityGroup
        SubnetIds:
          - Fn::ImportValue: !Sub ${vpcStack}-PrivateSubnetA
          - Fn::ImportValue: !Sub ${vpcStack}-PrivateSubnetB
      Environment:
        Variables:
          CLIENT_ID: 
            Fn::ImportValue: !Sub ${cognitoStack}-APIClientID
          POOL_ID:
            Fn::ImportValue: !Sub ${cognitoStack}-UserPoolID
          # POSTGRES_DB: !Ref applicationName
          # POSTGRES_HOST: !Sub '{{resolve:secretsmanager:${applicationName}-${environmentName}-dbHost:SecretString}}'
          # POSTGRES_USER: !Sub '{{resolve:secretsmanager:${applicationName}-${environmentName}-dbUsername:SecretString}}'
          # POSTGRES_PASSWORD: !Sub '{{resolve:secretsmanager:${applicationName}-${environmentName}-dbPassword:SecretString}}'
      Timeout: 180

  LambdaEta:
    Type: AWS::Lambda::Function
    Properties: 
      FunctionName: !Sub ${applicationName}-lambda-eta-${environmentName}
      Code:
        ImageUri: !Sub
          - "${ecrRepo}:${environment}"
          - ecrRepo:
              Fn::ImportValue: !Sub ${repoStack}-LambdaEtaImageRepository
            environment: !Ref environmentName
      PackageType: Image
      Role:
        Fn::ImportValue: !Sub ${iamStack}-LambdaExecutorRoleArn
      VpcConfig:
        SecurityGroupIds: 
          - Fn::ImportValue: !Sub ${vpcStack}-DatabaseSecurityGroup
        SubnetIds:
          - Fn::ImportValue: !Sub ${vpcStack}-PrivateSubnetA
          - Fn::ImportValue: !Sub ${vpcStack}-PrivateSubnetB
      Environment:
        Variables:
          CLIENT_ID: 
            Fn::ImportValue: !Sub ${cognitoStack}-APIClientID
          POOL_ID:
            Fn::ImportValue: !Sub ${cognitoStack}-UserPoolID
          # POSTGRES_DB: !Ref applicationName
          # POSTGRES_HOST: !Sub '{{resolve:secretsmanager:${applicationName}-${environmentName}-dbHost:SecretString}}'
          # POSTGRES_USER: !Sub '{{resolve:secretsmanager:${applicationName}-${environmentName}-dbUsername:SecretString}}'
          # POSTGRES_PASSWORD: !Sub '{{resolve:secretsmanager:${applicationName}-${environmentName}-dbPassword:SecretString}}'
      Timeout: 180
  
  # JIRA Integration Lambda
  LambdaZeta: 
    Type: AWS::Lambda::Function
    Properties: 
      FunctionName: !Sub ${applicationName}-lambda-zeta-${environmentName}
      Code:
        ImageUri: !Sub
          - "${ecrUri}:${tag}"
          - ecrUri:
              Fn::ImportValue: !Sub ${repoStack}-LambdaZetaImageRepository
            tag: !Ref environmentName
      PackageType: Image
      Role:
        Fn::ImportValue: !Sub ${iamStack}-LambdaExecutorRoleArn
      Environment:
        Variables:
          ATLASSIAN_TOKEN: !Sub '{{resolve:secretsmanager:${applicationName}-atlassianToken:SecretString}}'
      Timeout: 180

  ### LAMBDA INTEGRATIONS
  ## API GATEWAY INTEGRATION
  RestAPI:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: !Sub ${applicationName}-${environmentName}-rest-api

  CloudWatch:
    Type: AWS::ApiGateway::Account
    Properties:
      CloudWatchRoleArn: 
        Fn::ImportValue: !Sub ${iamStack}-LoggerArn
  
  CloudWatchLogGroup:
    Type: AWS::Logs::LogGroup
    Properties: 
      LogGroupName: !Sub ${AWS::StackName}-LogGroup
      RetentionInDays: 30

  RestAPIDeployment:
    Type: AWS::ApiGateway::Deployment
    Properties:
      RestApiId: !Ref RestAPI
      Description: !Sub "${applicationName}'s RestAPI ${environmentName} deployment"
      StageName: !Ref environmentName
      StageDescription:
        AccessLogSetting:
          DestinationArn: !GetAtt CloudWatchLogGroup.Arn
        LoggingLevel: INFO
        MetricsEnabled: True
        MethodSettings:
          - ResourcePath: "/*"
            HttpMethod: "*"
            LoggingLevel: INFO
            MetricsEnabled: True
    DependsOn:
      - CloudWatch
      - CloudWatchLogGroup
      - InnoLabImageVersionResourceMethod

  ## NOTE: Add these two lines to the AWS::ApiGateway::Method properties to attach an authorizer
  ##        to a Gateway endpoint
  #  Properties:
  #     AuthorizationType: COGNITO_USER_POOL
  #     AuthorizerId: !Ref ApiAuthorizer
  ApiGatewayAuthorizer:
    Type: AWS::ApiGateway::Authorizer
    Properties:
      RestApiId: !Ref RestAPI
      Name: !Sub ${AWS::StackName}-Authorizer
      Type: COGNITO_USER_POOLS
      IdentitySource: method.request.header.authorization
      ProviderARNs:
        - Fn::ImportValue: !Sub ${cognitoStack}-UserPoolArn

  InnoLabRootResource: 
    Type: 'AWS::ApiGateway::Resource'
    Properties: 
      RestApiId: !Ref RestAPI
      ParentId: !GetAtt RestAPI.RootResourceId
      PathPart: innolab
    DependsOn:
      - RestAPI

  InnoLabLambdaResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref RestAPI
      ParentId: !Ref InnoLabRootResource
      PathPart: lambdas
    DependsOn:
      - InnoLabRootResource

  InnoLabImageResource:
    Type: 'AWS::ApiGateway::Resource'
    Properties:
      RestApiId: !Ref RestAPI
      ParentId: !Ref InnoLabLambdaResource
      PathPart: images
    DependsOn:
      - InnoLabRootResource

  InnoLabImageVersionResource:
    Type: 'AWS::ApiGateway::Resource'
    Properties:
      RestApiId: !Ref RestAPI
      ParentId: !Ref InnoLabImageResource
      PathPart: "{repo}"
    DependsOn:
      - InnoLabImageResource

  InnoLabImageVersionResourceMethod:
    Type: 'AWS::ApiGateway::Method'
    Properties:
      RestApiId: !Ref RestAPI
      ResourceId: !Ref InnoLabImageVersionResource
      HttpMethod: GET
      RequestParameters:
        "method.request.path.repo": true
      AuthorizationType: None
      Integration:
        Type: AWS_PROXY
        # INTEGRATION HTTP METHOD MUST BE POST
        #   NOTE: API Gateway transforms all incoming requests into POSTS
        IntegrationHttpMethod: POST
        Uri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${LambdaAlpha.Arn}/invocations"
    DependsOn:
      - InnoLabImageVersionResource

  InnoLabImageVersionResourceCORS:
    Type: AWS::ApiGateway::Method
    Properties:
      AuthorizationType: NONE
      RestApiId: !Ref RestAPI
      ResourceId: !Ref InnoLabImageVersionResource
      HttpMethod: OPTIONS
      Integration:
        IntegrationResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
            # method.response.header.Access-Control-Allow-Methods: "'*'"
            method.response.header.Access-Control-Allow-Methods: "'POST,GET,OPTIONS'"
            method.response.header.Access-Control-Allow-Origin: "'*'"
          ResponseTemplates:
            application/json: ''
        PassthroughBehavior: WHEN_NO_MATCH
        RequestTemplates:
          application/json: '{"statusCode": 200}'
        Type: MOCK
      MethodResponses:
      - StatusCode: 200
        ResponseModels:
          application/json: 'Empty'
        ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: false
            method.response.header.Access-Control-Allow-Methods: false
            method.response.header.Access-Control-Allow-Origin: false
    DependsOn:
      - InnoLabImageVersionResource

  ## API GATEWAY LAMBDA PERMISSIONS
  ##  NOTE: the arn is of the form arn:aws:execute-api:region:account-id:api-name/env-name/{METHOD}/{ENDPOINT_PATH}
  ##        where METHOD is the HTTP method API gateway is using to invoke Lambda and ENDPOINT_PATH is the URI of 
  ##        the API gateway endpoint invoking. 
  LambdaAlphaApiGatewayInvoke:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !GetAtt LambdaAlpha.Arn
      Principal: apigateway.amazonaws.com
      SourceArn: 
        !Sub arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${RestAPI}/${environmentName}/*/innolab/lambdas/images/*
    DependsOn:
      - RestAPIDeployment

  ## CLOUDWATCH EVENT INTEGRATIONS
  ### MULTIPLE ENVIRONMENT RULES
  LambdaZetaBackendEventRule:
    Type: AWS::Events::Rule
    Properties:
      EventPattern:
        source:
          - aws.codecommit
        detail-type:
          - 'CodeCommit Repository State Change'
        resources:
          - Fn::ImportValue: !Sub "${repoStack}-BackendRepositoryARN"
        detail:
          event:
            - referenceCreated
            - referenceUpdated
          referenceType:
            - branch
          referenceName:
            - !Ref environmentName
      Targets:
        - Arn: !GetAtt LambdaZeta.Arn
          Id: !Sub "${applicationName}-cloudwatch-backend-${environmentName}"

  LambdaZetaFrontendEventRule:
    Type: AWS::Events::Rule
    Properties:
      EventPattern:
        source:
          - aws.codecommit
        detail-type:
          - 'CodeCommit Repository State Change'
        resources:
          - Fn::ImportValue: !Sub "${repoStack}-FrontendRepositoryARN"
        detail:
          event:
            - referenceCreated
            - referenceUpdated
          referenceType:
            - branch
          referenceName:
            - !Ref environmentName
      Targets:
        - Arn: !GetAtt LambdaZeta.Arn
          Id: !Sub "${applicationName}-cloudwatch-frontend-${environmentName}"

  LambdaZetaLambdaEventRule:
    Type: AWS::Events::Rule
    Properties:
      EventPattern:
        source:
          - aws.codecommit
        detail-type:
          - 'CodeCommit Repository State Change'
        resources:
          - Fn::ImportValue: !Sub "${repoStack}-LambdaRepositoryARN"
        detail:
          event:
            - referenceCreated
            - referenceUpdated
          referenceType:
            - branch
          referenceName:
            - !Ref environmentName
      Targets:
        - Arn: !GetAtt LambdaZeta.Arn
          Id: !Sub "${applicationName}-cloudwatch-lambda-${environmentName}"

  ### SINGLE ENVIRONMENT RULES (note Condition!)
  LambdaZetaCloudFormationEventRule:
    Type: AWS::Events::Rule
    Condition: DevResources
    Properties:
      EventPattern:
        source:
          - aws.codecommit
        detail-type:
          - 'CodeCommit Repository State Change'
        resources:
          - Fn::ImportValue: !Sub "${repoStack}-CloudFormationRepositoryARN"
        detail:
          event:
            - referenceCreated
            - referenceUpdated
          referenceType:
            - branch
          referenceName:
            - master
      Targets:
        - Arn: !GetAtt LambdaZeta.Arn
          Id: !Sub "${applicationName}-cloudwatch-cloudformation-master"
  
  LambdaZetaMasterEventRule:
    Type: AWS::Events::Rule
    Condition: DevResources
    Properties:
      EventPattern:
        source:
          - aws.codecommit
        detail-type:
          - 'CodeCommit Repository State Change'
        resources:
          - Fn::ImportValue: !Sub "${repoStack}-MasterRepositoryARN"
        detail:
          event:
            - referenceCreated
            - referenceUpdated
          referenceType:
            - branch
          referenceName:
            - master
      Targets:
        - Arn: !GetAtt LambdaZeta.Arn
          Id: !Sub "${applicationName}-cloudwatch-master"

  ### MULTIPLE ENVIRONMENT INVOCATIONS        
  LambdaZetaCloudWatchLambdaInvoke: 
    Type: AWS::Lambda::Permission
    Properties: 
      FunctionName: !Sub ${applicationName}-lambda-zeta-${environmentName}
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt LambdaZetaLambdaEventRule.Arn
    DependsOn:
      - LambdaZetaLambdaEventRule

  LambdaZetaCloudWatchFrontendInvoke: 
    Type: AWS::Lambda::Permission
    Properties: 
      FunctionName: !Sub ${applicationName}-lambda-zeta-${environmentName}
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt LambdaZetaFrontendEventRule.Arn
    DependsOn:
      - LambdaZetaFrontendEventRule

  LambdaZetaCloudWatchBackendInvoke: 
    Type: AWS::Lambda::Permission
    Properties: 
      FunctionName: !Sub ${applicationName}-lambda-zeta-${environmentName}
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt LambdaZetaBackendEventRule.Arn
    DependsOn:
      - LambdaZetaBackendEventRule

  ### SINGLE ENVIROMENT INVOCATIONS (note Condition!)
  LambdaZetaCloudWatchMasterInvoke: 
    Type: AWS::Lambda::Permission
    Condition: DevResources
    Properties: 
      FunctionName: !Sub ${applicationName}-lambda-zeta-Dev
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt LambdaZetaMasterEventRule.Arn
    DependsOn:
      - LambdaZetaMasterEventRule
  
  LambdaZetaCloudWatchCloudFormationInvoke: 
    Type: AWS::Lambda::Permission
    Condition: DevResources
    Properties: 
      FunctionName: !Sub ${applicationName}-lambda-zeta-Dev
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt LambdaZetaCloudFormationEventRule.Arn
    DependsOn:
      - LambdaZetaCloudFormationEventRule

  ## DNS CONFIGURATION
  RestAPIDomainName:
    Type: 'AWS::ApiGateway::DomainName'
    Properties:
      CertificateArn: !Ref certificateArn
      DomainName: !Sub 
        - "apigateway${subdomainEnv}.${domain}"
        - subdomainEnv: 
            Fn::FindInMap:
              - BranchMap
              - !Ref environmentName
              - subdomain
          domain: !Ref domainName
      EndpointConfiguration:
        Types:
          - EDGE

  RestAPIBasePathMapping:
    Type: 'AWS::ApiGateway::BasePathMapping'
    Properties:
      DomainName: !Ref RestAPIDomainName
      RestApiId: !Ref RestAPI
      Stage: !Ref environmentName

  RestAPIRoute53RecordSetGroup:
    Type: AWS::Route53::RecordSetGroup
    Properties:
      HostedZoneId: !Ref hostedZoneId
      RecordSets:
        - Name: !Sub 
            - "apigateway${subdomainEnv}.${domain}"
            - subdomainEnv: 
                Fn::FindInMap:
                  - BranchMap
                  - !Ref environmentName
                  - subdomain
              domain: !Ref domainName
          Type: A
          AliasTarget:
            HostedZoneId: !GetAtt RestAPIDomainName.DistributionHostedZoneId
            DNSName: !GetAtt RestAPIDomainName.DistributionDomainName
    DependsOn:
      - RestAPIDomainName

Outputs:
  LambdaAlphaArn:
    Value: !GetAtt LambdaAlpha.Arn
    Export:
      Name: !Sub ${AWS::StackName}-LambdaAlphaARN
  LambdaBetaArn:
    Value: !GetAtt LambdaBeta.Arn
    Export:
      Name: !Sub ${AWS::StackName}-LambdaBetaARN
  LambdaGammaArn:
    Value: !GetAtt LambdaGamma.Arn
    Export:
      Name: !Sub ${AWS::StackName}-LambdaGammaARN
  LambdaDeltaArn:
    Value: !GetAtt LambdaDelta.Arn
    Export: 
      Name: !Sub ${AWS::StackName}-LambdaDeltaARN
  LambdaEpsilonArn:
    Value: !GetAtt LambdaEpsilon.Arn
    Export: 
      Name: !Sub ${AWS::StackName}-LambdaEpsilonARN
  LambdaEtArn:
    Value: !GetAtt LambdaEta.Arn
    Export:
      Name: !Sub ${AWS::StackName}-LambdaEtaARN
  LambdaZetaArn:
    Value: !GetAtt LambdaZeta.Arn
    Export:
      Name: !Sub ${AWS::StackName}-LambdaZetaARN

  GatewayEndpoint:
    Value: !Sub https://${RestAPI}.execute-api.${AWS::Region}.amazonaws.com/${environmentName}
    Export:
      Name: !Sub ${AWS::StackName}-GatewayEndpoint
  RestAPIID: 
    Value: !Ref RestAPI
    Export:
      Name: !Sub ${AWS::StackName}-RestAPIID


  ## EXAMPLE PATH INTEGRATIONS
  ### PATH INTEGRATION
  #### RESOURCE
  # InnoLabRootResource: 
  #   Type: 'AWS::ApiGateway::Resource'
  #   Properties: 
  #     RestApiId: !Ref RestAPI
  #     ParentId: !GetAtt RestAPI.RootResourceId
  #     PathPart: innolab
  #   DependsOn:
  #     - RestAPI
  #### RESOURCE METHOD
  # PathResourceMethod:
  #   Type: 'AWS::ApiGateway::Method'
  #   Properties:
  #     RestApiId: !Ref RestAPI
  #     ResourceId: !Ref PathResource
  #     HttpMethod: ANY
  #     AuthorizationType: COGNITO_USER_POOLS
  #     AuthorizerId: !Ref ApiGatewayAuthorizer
  #     Integration:
  #       Type: AWS_PROXY
  #       # INTEGRATION HTTP METHOD MUST BE POST
  #        # NOTE: API Gateway transforms all incoming requests into POSTS
  #       IntegrationHttpMethod: POST
  #       Uri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${LambdaAlpha.Arn}/invocations"
  #   DependsOn:
  #     - PathResource
  #### CORS RESOURCE METHOD
  # PathResourceCORS:
  #   Type: AWS::ApiGateway::Method
  #   Properties:
  #     AuthorizationType: NONE
  #     RestApiId: !Ref RestAPI
  #     ResourceId: !Ref PathResource
  #     HttpMethod: OPTIONS
  #     Integration:
  #       IntegrationResponses:
  #       - StatusCode: 200
  #         ResponseParameters:
  #           method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
  #           method.response.header.Access-Control-Allow-Methods: "'*'"
  #           method.response.header.Access-Control-Allow-Origin: "'*'"
  #         ResponseTemplates:
  #           application/json: ''
  #       PassthroughBehavior: WHEN_NO_MATCH
  #       RequestTemplates:
  #         application/json: '{"statusCode": 200}'
  #       Type: MOCK
  #     MethodResponses:
  #     - StatusCode: 200
  #       ResponseModels:
  #         application/json: 'Empty'
  #       ResponseParameters:
  #           method.response.header.Access-Control-Allow-Headers: false
  #           method.response.header.Access-Control-Allow-Methods: false
  #           method.response.header.Access-Control-Allow-Origin: false
  #   DependsOn: 
  #     - PathResource
  # 
  ### PATH PARAMETER INTEGRATION
  #### RESOURCE
  # PathParamResource:
  #   Type: 'AWS::ApiGateway::Resource'
  #   Properties:
  #     RestApiId: !Ref RestAPI
  #     ParentId: !Ref PathResource
  #     PathPart: "{param}"
  #   DependsOn:
  #     - RestAPI
  #     - PathResource
  #### RESOURCE METHOD
  # PathParamResourceMethod:
  #   Type: 'AWS::ApiGateway::Method'
  #   Properties:
  #     RestApiId: !Ref RestAPI
  #     ResourceId: !Ref PathParamResource
  #     HttpMethod: ANY
  #     RequestParameters:
  #       "method.request.path.param": true
  #     AuthorizationType: COGNITO_USER_POOLS
  #     AuthorizerId: !Ref ApiGatewayAuthorizer
  #     Integration:
  #       Type: AWS_PROXY
  #       # INTEGRATION HTTP METHOD MUST BE POST
  #       #   NOTE: API Gateway transforms all incoming requests into POSTS
  #       IntegrationHttpMethod: POST
  #       Uri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${LambdaBeta.Arn}/invocations"
  #   DependsOn:
  #     - PathResource
  #     - PathParamResource
  #### CORS RESOURCE METHOD
  # PathParamResourceCORS:
  #   Type: AWS::ApiGateway::Method
  #   Properties:
  #     AuthorizationType: NONE
  #     RestApiId: !Ref RestAPI
  #     ResourceId: !Ref PathParamResource
  #     HttpMethod: OPTIONS
  #     Integration:
  #       IntegrationResponses:
  #       - StatusCode: 200
  #         ResponseParameters:
  #           method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
  #           # method.response.header.Access-Control-Allow-Methods: "'*'"
  #           method.response.header.Access-Control-Allow-Methods: "'POST,GET,OPTIONS'"
  #           method.response.header.Access-Control-Allow-Origin: "'*'"
  #         ResponseTemplates:
  #           application/json: ''
  #       PassthroughBehavior: WHEN_NO_MATCH
  #       RequestTemplates:
  #         application/json: '{"statusCode": 200}'
  #       Type: MOCK
  #     MethodResponses:
  #     - StatusCode: 200
  #       ResponseModels:
  #         application/json: 'Empty'
  #       ResponseParameters:
  #           method.response.header.Access-Control-Allow-Headers: false
  #           method.response.header.Access-Control-Allow-Methods: false
  #           method.response.header.Access-Control-Allow-Origin: false
  #   DependsOn:
  #     - PathParamResource